#pragma once

namespace std
{
    template <typename T>
    class list
    {
    private:
        struct list_node
        {
            T data = {};
            list_node* next = nullptr;
            list_node* prev = nullptr;
        };

        list_node* _head = nullptr;
        list_node* _tail = nullptr;
        size_t _size = 0;

    public:
        class iterator
        {
        public:
            iterator(list_node* ptr)
            :
            _node(ptr)
            {
            }

            iterator& operator++()
            {
                _node = _node->next;

                return *this;
            }

            iterator operator++(int)
            {
                iterator iterator = *this;
                ++(*this);

                return iterator;
            }

            iterator& operator--()
            {
                _node = _node->prev;

                return *this;
            }

            iterator operator--(int)
            {
                iterator iterator = *this;
                --(*this);

                return iterator;
            }

            T* operator->()
            {
                return &_node->data;
            }

            T& operator*()
            {
                return _node->data;
            }

            bool operator==(const iterator& rhs)
            {
                return _node == rhs._node;
            }

            bool operator!=(const iterator& rhs)
            {
                return _node != rhs._node;
            }
        private:
            list_node* _node;
        };

        void push_back(const T& value)
        {
            list_node* prev_node = _tail;

            list_node* node = new list_node;
            if(_tail != nullptr) _tail->next = node;

            _tail = node;
            node->data = value;
            node->prev = prev_node;
        }

        void push_front(const T& value)
        {
            list_node* next_node = _head;

            list_node* node = new list_node;
            if(_head != nullptr) _head->prev = node;

            _head = node;
            node->data = value;
            node->next = next_node;
        }

        size_t size() const
        {
            return _size;
        }

        bool empty() const
        {
            return _size == 0;
        }

        void clear()
        {
            list_node* n = _head;

            while(n != nullptr)
            {
                list_node* next_node = n.next;

                delete n;
                n = next_node;
            }

            _head = nullptr;
            _tail = nullptr;
        }

        iterator begin()
        {
            return iterator(_head);
        }

        iterator end()
        {
            return iterator(_tail);
        }
    };
}
