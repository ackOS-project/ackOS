#pragma once

#include <cstdint>
#include <cstring>

namespace std
{
    template<typename T>
    class basic_string
    {
    private:
        T* _str = nullptr;
        size_t _size = 0;
        size_t _capacity = 0;

    public:
        basic_string()
        {
            resize(5);
        }

        basic_string(const char* str)
        {
            operator=(str);
        }

        basic_string(const basic_string<T>& old)
        {
            _size = old.size();
            _capacity = old.capacity();
            _str = new T[_capacity];

            memcpy((void*)_str, (const void*)old._str, size());
        }

        void operator=(const char* str)
        {
            resize(strlen(str));
            strcpy(_str, str);
        }

        void operator+=(const std::basic_string<T>& str)
        {
            size_t old_size = length();
            size_t str_size = str.length();

            resize(length() + str_size);
            
            for(int i = 0; i < str_size; i++)
            {
                _str[old_size + i] = str[i];
            }
        }

        void operator+=(const char* cstr)
        {
            if(cstr == nullptr)
            {
                return;
            }

            operator+=(std::basic_string<T>(cstr));
        }

        std::basic_string<T> operator+(const std::basic_string<T>& rhs)
        {
            std::basic_string<T> s;
            s += *this;
            s += rhs;

            return s;
        }

        void resize(size_t size)
        {
            _capacity = size;
            _size = size;

            T* new_str = new T[_capacity];

            if(_str != nullptr)
            {
                memcpy((void*)new_str, (const void*)_str, size);

                delete[] _str;
            }
            _str = new_str;
        }

        T& at(int index) const
        {
            return _str[index];
        }

        T& operator[](int index) const
        {
            return at(index);
        }

        const T* c_str() const
        {
            return _str;
        }

        void clear()
        {
            memset(_str, '\0', _size);
        }

        size_t length() const
        {
            return _size;
        }

        size_t size() const
        {
            return _size;
        }

        size_t capacity() const
        {
            return _capacity;
        }

        ~basic_string()
        {
            if(_str != nullptr)
            {
                delete[] _str;
            }
        }
    };

    using string = basic_string<char>;
}
