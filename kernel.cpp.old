void timer_wait(int ticks)
{
    unsigned int eticks;
    unsigned int timer_ticks;

    eticks = timer_ticks + ticks;
    while(timer_ticks < eticks) 
    {
        __asm__ __volatile__ ("sti//hlt//cli");
    }
}
bool isShiftDown;
extern void loadPageDirectory(unsigned int*);
extern void enablePaging();
#define KBRD_INTRFC 0x64
 

// Hardware comunication
uint8_t inb (uint16_t _port)
{
    	uint8_t rv;
    	__asm__ __volatile__ ("inb %1, %0" : "=a" (rv) : "dN" (_port));
    	return rv;
}

void outb (uint16_t _port, uint8_t _data)
{
	__asm__ __volatile__ ("outb %1, %0" : : "dN" (_port), "a" (_data));
}

/* keyboard interface bits */
#define KBRD_BIT_KDATA 0 /* keyboard data is in buffer (output buffer is empty) (bit 0) */
#define KBRD_BIT_UDATA 1 /* user data is in buffer (command buffer is empty) (bit 1) */
 
#define KBRD_IO 0x60 /* keyboard IO port */
#define KBRD_RESET 0xFE /* reset CPU command */
 
#define bit(n) (1<<(n)) /* Set bit n to 1 */
 
/* Check if bit n in flags is set */
#define check_flag(flags, n) ((flags) & bit(n))
void outw(uint16_t portid, uint16_t value)
{
	asm volatile("outw %%ax, %%dx": :"d" (portid), "a" (value));
}
void reboot()
{
    uint8_t temp;
 
    asm volatile ("cli"); /* disable all interrupts */
 
    /* Clear all keyboard buffers (output and command buffers) */
    do
    {
        temp = inb(KBRD_INTRFC); /* empty user data */
        if (check_flag(temp, KBRD_BIT_KDATA) != 0)
            inb(KBRD_IO); /* empty keyboard data */
    } while (check_flag(temp, KBRD_BIT_UDATA) != 0);
 
    outb(KBRD_INTRFC, KBRD_RESET); /* pulse CPU reset line */
loop:
    asm volatile ("hlt"); /* if that didn't work, halt the CPU */
    goto loop; /* if a NMI is received, halt again */
}
void shutdown(){
        outw(0xB004, 0x2000);
        outw(0x604, 0x2000);
        outw(0x4004, 0x3400);
}
static inline void lidt(void* base, uint16_t size)
{
    struct {
        uint16_t length;
        void*    base;
    } __attribute__((packed)) IDTR = { size, base };
 
    asm ( "lidt %0" : : "m"(IDTR) );  // let the compiler choose an addressing mode
}

void printf(char* str)
{
    static uint16_t* VideoMemory = (uint16_t*)0xb8000;

    static uint8_t x=0,y=0;
    
    for(int i = 0; str[i] != '\0'; ++i)
    {
        switch(str[i])
        {
            case '\n':
                x = 0;
                y++;
                break;
            default:
                VideoMemory[80*y+x] = (VideoMemory[80*y+x] & 0x1010) | str[i];
                x++;
                break;
        }
        
        if(x >= 80)
        {
            x = 0;
            y++;
        }
        
        if(y >= 25)
        {
            for(y = 0; y < 25; y++)
                for(x = 0; x < 80; x++)
                    VideoMemory[80*y+x] = (VideoMemory[80*y+x] & 0x1010) | ' ';
            x = 0;
            y = 0;
        }
    }
}
 
int charToInt(const char* str){
        if(str == "0"){
        /* code */
        return 0;
        }else if(str == "1"){
        /* code */
        return 1;
        }else if(str == "2"){
        /* code */
        return 2;
        }else if(str == "3"){
        /* code */
        return 3;
        }
        else if(str == "4"){
        /* code */
        return 4;
        }        
        else if(str == "5"){
        /* code */
        return 5;
        }
        else if(str == "6"){
        /* code */
        return 6;
        }
        else if(str == "7"){
        /* code */
        return 7;
        }
        else if(str == "8"){
        /* code */
        return 8;
        }
        else if(str == "9"){
        /* code */
        return 9;
        }
        else{
        return 0;
        }
}
int charToInt(char* str){
        charToInt(&str[0]);
}
int atoi(const char* str){
        
}
char * itoa( int value, char * str, int base )
{
    char * rc;
    char * ptr;
    char * low;
    // Check for supported base.
    if ( base < 2 || base > 36 )
    {
        *str = '\0';
        return str;
    }
    rc = ptr = str;
    // Set '-' for negative decimals.
    if ( value < 0 && base == 10 )
    {
        *ptr++ = '-';
    }
    // Remember where the numbers start.
    low = ptr;
    // The actual conversion.
    do
    {
        // Modulo is negative for negative value. This trick makes abs() unnecessary.
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"[35 + value % base];
        value /= base;
    } while ( value );
    // Terminating the string.
    *ptr-- = '\0';
    // Invert the numbers.
    while ( low < ptr )
    {
        char tmp = *low;
        *low++ = *ptr;
        *ptr-- = tmp;
    }
    return rc;
}
/* Hardware text mode colour constants. */
enum vga_colour {
	VGA_COLOUR_BLACK = 0,
	VGA_COLOUR_BLUE = 1,
	VGA_COLOUR_GREEN = 2,
	VGA_COLOUR_CYAN = 3,
	VGA_COLOUR_RED = 4,
	VGA_COLOUR_MAGENTA = 5,
	VGA_COLOUR_BROWN = 6,
	VGA_COLOUR_LIGHT_GREY = 7,
	VGA_COLOUR_DARK_GREY = 8,
	VGA_COLOUR_LIGHT_BLUE = 9,
	VGA_COLOUR_LIGHT_GREEN = 10,
	VGA_COLOUR_LIGHT_CYAN = 11,
	VGA_COLOUR_LIGHT_RED = 12,
	VGA_COLOUR_LIGHT_MAGENTA = 13,
	VGA_COLOUR_LIGHT_BROWN = 14,
	VGA_COLOUR_WHITE = 15,
};


static inline uint8_t vga_entry_colour(enum vga_colour fg, enum vga_colour bg) 
{
	return fg | bg << 4;
}
 
static inline uint16_t vga_entry(unsigned char uc, uint8_t colour) 
{
	return (uint16_t) uc | (uint16_t) colour << 8;
}

/*
size_t strlen(const char* str) 
{
	size_t len = 0;
	while (str[len])
		len++;
	return len;
}
size_t strlen(char* str) 
{
	size_t len = 0;
	while (str[len])
		len++;
	return len;
}

static const size_t VGA_WIDTH = 80;
static const size_t VGA_HEIGHT = 25;
 
size_t terminal_row;
size_t terminal_column;
uint8_t terminal_colour;
uint16_t* terminal_buffer;
void enable_cursor(uint8_t cursor_start, uint8_t cursor_end)
{
	outb(0x3D4, 0x0A);
	outb(0x3D5, (inb(0x3D5) & 0xC0) | cursor_start);
 
	outb(0x3D4, 0x0B);
	outb(0x3D5, (inb(0x3D5) & 0xE0) | cursor_end);
}
void disable_cursor()
{
        outb(0x3D4, 0x0A);
	outb(0x3D5, 0x20);
}
void change_cursor_pos(int x, int y)
{
	uint16_t pos = y * VGA_WIDTH + x;
 
	outb(0x3D4, 0x0F);
	outb(0x3D5, (uint8_t) (pos & 0xFF));
	outb(0x3D4, 0x0E);
	outb(0x3D5, (uint8_t) ((pos >> 8) & 0xFF));
}
void update_cursor(void){
        change_cursor_pos(terminal_column,terminal_row);
}
void terminal_initialize(void) 
{
	terminal_row = 0;
	terminal_column = 0;
	terminal_colour = vga_entry_colour(VGA_COLOUR_LIGHT_GREY, VGA_COLOUR_BLACK);
	terminal_buffer = (uint16_t*) 0xC03FF000;
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
		for (size_t x = 0; x < VGA_WIDTH; x++) {
			const size_t index = y * VGA_WIDTH + x;
			terminal_buffer[index] = vga_entry(' ', terminal_colour);
		}
	}
}
 void terminal_clear(void){
	terminal_row = 0;
	terminal_column = 0;
	terminal_buffer = (uint16_t*) 0xB8000;
	for (size_t y = 0; y < VGA_HEIGHT; y++) {
		for (size_t x = 0; x < VGA_WIDTH; x++) {
			const size_t index = y * VGA_WIDTH + x;
			terminal_buffer[index] = vga_entry(' ', terminal_colour);
		}
	}
}
void terminal_setcolour(uint8_t colour) 
{ 
	terminal_colour = colour;
}
void count_memory(void)
{

}
void terminal_putentryat(char c, uint8_t colour, size_t x, size_t y) 
{
        if(terminal_row == VGA_WIDTH){terminal_clear();}
	const size_t index = y * VGA_WIDTH + x;
	terminal_buffer[index] = vga_entry(c, colour);
}
 
void terminal_putchar(char c) 
{
	if(c != '\n'){
		terminal_putentryat(c, terminal_colour, terminal_column, terminal_row);

        }
	if (++terminal_column == VGA_WIDTH) {
		terminal_column = 0;
		if (++terminal_row == VGA_HEIGHT){
			terminal_row = 0;//qemu-system-i386 -cdrom myos.iso
		}
	}
	if(c == '\n'){
		terminal_row= terminal_row + 1;
		terminal_column = 0;
	}
	update_cursor();
}
void terminal_backspace(){
        if(terminal_row == 0 && terminal_column != 0){
		terminal_putentryat(' ', terminal_colour, terminal_column + 1, terminal_row + 1);

        }else{
	terminal_putentryat(' ', terminal_colour, terminal_column, terminal_row);
        }
        update_cursor();
}
int number_of_digits(int num) {
   int count = 0;
   while (num != 0) {   
      count++;  
      num /= 10;
   } 
   return count;
}
char* convert_to_str(int input){
	char buffer[20];
	char* itoaResult = itoa(input,buffer,10);
	return itoaResult;
}

void terminal_write(const char* data, size_t size) 
{
	for (size_t i = 0; i < size; i++)
		terminal_putchar(data[i]);
}
 
void terminal_writestring(const char* data) 
{
	terminal_write(data, strlen(data));
}
void printError(const char* data){
	terminal_setcolour(4);
	terminal_writestring(data);
}
uint64_t descriptor;
void create_descriptor(uint32_t base, uint32_t limit, uint16_t flag)
{
 
    // Create the high 32 bit segment
    descriptor  =  limit       & 0x000F0000;         // set limit bits 19:16
    descriptor |= (flag <<  8) & 0x00F0FF00;         // set type, p, dpl, s, g, d/b, l and avl fields
    descriptor |= (base >> 16) & 0x000000FF;         // set base bits 23:16
    descriptor |=  base        & 0xFF000000;         // set base bits 31:24
 
    // Shift by 32 to allow for low part of segment
    descriptor <<= 32;
 
    // Create the low 32 bit segment
    descriptor |= base  << 16;                       // set base bits 15:0
    descriptor |= limit  & 0x0000FFFF;               // set limit bits 15:0
        terminal_writestring("\nSetting descriptor table: ");
	terminal_writestring(convert_to_str(descriptor));
//
}
bool normalCharListening;
void printch(const char* data){
	if(normalCharListening){
        terminal_writestring(data);
        }else
        {
        char* x = (char*)data;
        //terminal_putentryat(x[0], terminal_colour, 11, 10);
        const size_t index = 8 * VGA_WIDTH + 1;
        terminal_buffer[index] = vga_entry(x[0], terminal_colour);
        }
}

 
unsigned char mouse_cycle=0;     //unsigned char
signed char mouse_byte[3];    //signed char
signed char mouse_x=0;         //signed char
signed char mouse_y=0;         //signed char

//Mouse functions
void mouse_handler(struct regs *a_r) //struct regs *a_r (not used but just there)
{
  switch(mouse_cycle)
  {
    case 0:
      mouse_byte[0]=inb(0x60);
      mouse_cycle++;
      break;
    case 1:
      mouse_byte[1]=inb(0x60);
      mouse_cycle++;
      break;
    case 2:
      mouse_byte[2]=inb(0x60);
      mouse_x=mouse_byte[1];
      mouse_y=mouse_byte[2];
      mouse_cycle=0;
      break;
  }
}




const char* readStr(bool numonly)
{
    char buff;
    const char* buffstr;
    int i = 0;
    int reading = 1;

    while(reading)
    {
        if(inb(0x64) & 0x1)                 
        {
        if(isShiftDown){
                buffstr = "c";
        }
        if(!numonly){
        switch(inb(0x60))
        { 
        case 1:
                //printch((char)27);           //Escape button
                buffstr = "";
                i++;
                break;
        case 2:
                printch("1");
                buffstr = "1";
                i++;
                break;
        case 3:
                printch("2");
                buffstr = "2";
                i++;
                break;
        case 4:
                printch("3");
                buffstr = "3";
                i++;
                break;
        case 5:
                printch("4");
                buffstr = "4";
                i++;
                break;
        case 6:
                printch("5");
                buffstr = "5";
                i++;
                break;
        case 7:
                printch("6");
                buffstr = "6";
                i++;
                break;
        case 8:
                printch("7");
                buffstr = "7";
                i++;
                break;
        case 9:
                printch("8");
                buffstr = "8";
                i++;
                break;
        case 10:
                printch("9");
                buffstr = "9";
                i++;
                break;
        case 11:
                printch("0");
                buffstr = "0";
                i++;
                break;
        case 12:
                printch("-");
                buffstr = "-";
                i++;
                break;
        case 13:
                printch("=");
                buffstr = "=";
                i++;
                break;
        case 14:
                printch("\0");
                //i--;
                buffstr = "\0";
		terminal_column = terminal_column -1;
		terminal_backspace();
                break;
       /* case 15:
                printch("\t");          Tab button
                buffstr = "\t";
                i++;
                break;*/
        case 16:
                printch("q");
                buffstr = "q";
                i++;
                break;
        case 17:
                printch("w");
                buffstr = "w";
                i++;
                break;
        case 18:
                printch("e");
                buffstr = "e";
                i++;
                break;
        case 19:
                printch("r");
                buffstr = "r";
                i++;
                break;
        case 20:
                printch("t");
                buffstr = "t";
                i++;
                break;
        case 21:
                printch("y");
                buffstr = "y";
                i++;
                break;
        case 22:
                printch("u");
                buffstr = "u";
                i++;
                break;
        case 23:
                printch("i");
                buffstr = "i";
                i++;
                break;
        case 24:
                printch("o");
                buffstr = "o";
                i++;
                break;
        case 25:
                printch("p");
                buffstr = "p";
                i++;
                break;
        case 26:
                printch("[");
                buffstr = "[";
                i++;
                break;
        case 27:
                printch("]");
                buffstr = "]";
                i++;
                break;
        case 28:
               // printch("\n");
               // buffstr = "\n";
                  i++;
               reading = 0;
                break;
      /*  case 29:
                printch("q");           Left Control
                buffstr = "q";
                i++;
                break;*/
        case 30:
                printch("a");
                buffstr = "a";
                i++;
                break;
        case 31:
                printch("s");
                buffstr = "s";
                i++;
                break;
        case 32:
                printch("d");
                buffstr = "d";
                i++;
                break;
        case 33:
                printch("f");
                buffstr = "f";
                i++;
                break;
        case 34:
                printch("g");
                buffstr = "g";
                i++;
                break;
        case 35:
                printch("h");
                buffstr = "h";
                i++;
                break;
        case 36:
                printch("j");
                buffstr = "j";
                i++;
                break;
        case 37:
                printch("k");
                buffstr = "k";
                i++;
                break;
        case 38:
                printch("l");
                buffstr = "l";
                i++;
                break;
        case 39:
                printch(";");
                buffstr = ";";
                i++;
                break;
        case 40:
                printch((const char*)44);               //   Single quote (")
                buffstr = (const char*)44;
                i++;
                break;
        case 41:
                printch((const char*)44);               // Back tick (`)
                buffstr = (const char*)44;
                i++;
                break;
        case 42:                                 //Left shift 
                //printch("\0");
                isShiftDown = true;
                buffstr = "\0";
                i++;
                break;
        case 43:                                 //\ (< for somekeyboards)   
                printch((const char*)92);
                buffstr = "q";
                i++;
                break;
        case 44:
                printch("z");
                buffstr = "z";
                i++;
                break;
        case 45:
                printch("x");
                buffstr = "x";
                i++;
                break;
        case 46:
                printch("c");
                buffstr = "c";
                i++;
                break;
        case 47:
                printch("v");
                buffstr = "v";
                i++;
                break;                
        case 48:
                printch("b");
                buffstr = "b";
                i++;
                break;               
        case 49:
                printch("n");
                buffstr = "n";
                i++;
                break;                
        case 50:
                printch("m");
                buffstr = "m";
                i++;
                break;               
        case 51:
                printch(",");
                buffstr = ",";
                i++;
                break;                
        case 52:
                printch(".");
                buffstr = ".";
                i++;
                break;            
        case 53:
                printch("/");
                buffstr = "/";
                i++;
                break;            
        case 54:
                printch(".");
                buffstr = ".";
                i++;
                break;            
        case 55:
                printch("/");
                buffstr = "/";
                i++;
                break;            
      /*case 56:
                printch(" ");           Right shift
                buffstr = " ";
                i++;
                break;*/           
        case 57:
                printch(" ");
                buffstr = " ";
                i++;
                break;
            }
        }
        
        else{
        switch(inb(0x60))
        { 
        case 2:
                printch("1");
                buffstr = "1";
                i++;
                break;
        case 3:
                printch("2");
                buffstr = "2";
                i++;
                break;
        case 4:
                printch("3");
                buffstr = "3";
                i++;
                break;
        case 5:
                printch("4");
                buffstr = "4";
                i++;
                break;
        case 6:
                printch("5");
                buffstr = "5";
                i++;
                break;
        case 7:
                printch("6");
                buffstr = "6";
                i++;
                break;
        case 8:
                printch("7");
                buffstr = "7";
                i++;
                break;
        case 9:
                printch("8");
                buffstr = "8";
                i++;
                break;
        case 10:
                printch("9");
                buffstr = "9";
                i++;
                break;
        case 11:
                printch("0");
                buffstr = "0";
                i++;
                break;
        case 28:
               // printch("\n");
               // buffstr = "\n";
                i++;
                reading = 0;
                break;
        }
        }
        }
        }

    
    //buffstr = 0;       

    return buffstr;
}

const char* keyboardDriver(){
        int isRunning = 1;
        while (isRunning)
        {
                /* Keyboard events*/
        if(inb(0x64) & 0x1)                 
        {
                if(inb(0x60) == 0x1D){
                        terminal_writestring("a");
                }
        }
        }
        return (const char*)"/0";
}
//int get_mouse_location[1](){
        //return 
//}
/*
void terminal_writeInt(int data, uint8_t colour,int x,int y) 
{

	for (size_t i = 0; i < number_of_digits(data); i++){
		const size_t index = y * VGA_WIDTH + x;
		terminal_buffer[index] = (uint16_t) data | (uint16_t) colour << 8;
		if (++terminal_column == VGA_WIDTH) {
			terminal_column = 0;
		if (++terminal_row == VGA_HEIGHT){
			terminal_row = 0;//qemu-system-i386 -cdrom myos.iso
		}
	}
	}
}
*/ 
/*
const char* joinCharArr(const char* first, const char* second){
        char x[strlen(first) + strlen(second)];
        for(int i = 0; i < strlen(x); i++){
                if(i <= strlen(first)){
                        x[i] = first[i];
                        terminal_writestring(convert_to_str(i));

                }else{
                        x[i] = second[i];
                        terminal_writestring(convert_to_str(i));
                }
        }
        return (const char*)x;
}
*/
extern "C" void kernel_main(void) 
{
		// Setup paging
	// Initialize terminal interface
	terminal_initialize();
	// Change the colour 
	terminal_setcolour(VGA_COLOUR_LIGHT_GREEN);
	// Newline support is left as an exercise. You cannot change the colour of me after I have been written to the screen
	terminal_writestring("\nBooting C++ OS...\n");

	//char* myHungryChar[10000000000000000000000000000];
	//terminal_writestring(convert_to_str((int)GetMemorySize()));
	//terminal_writestring("KB of RAM\nNew Line\nNew line\nNEW LINE new line new line new line new line new line new line new line new line new line\nNew line \n new line \nNew line\n");
	terminal_writestring("+-- Options ------------------------------------+\n");
        terminal_writestring("| 1. Add numbers                                |\n");
        terminal_writestring("| 2. Shutdown                                   |\n");
        terminal_writestring("| 3. Reboot                                     |\n");
        terminal_writestring("|                                               |\n");
        terminal_writestring("+-----------------------------------------------+\n");
                             //terminal_clear();
        normalCharListening = false;
	//terminal_writestring("wv");
	terminal_writestring("[ ]");
	terminal_setcolour(4);
        //disable_cursor();
        enable_cursor(0,20);
        update_cursor();
        //unsigned char *vram = 't';
        //fillrect(3, 21, 10, 100, 100, 100);
	const char* result = readStr(1);
        if(result == "1"){
                /*
        printchar_at("c", VGA_WIDTH - 1, 0);
        printchar_at("h", VGA_WIDTH -1, 1);
        printchar_at("o", VGA_WIDTH-1, 2);
        printchar_at("o", VGA_WIDTH-1, 3);
        printchar_at("s", VGA_WIDTH-1, 4);
        printchar_at("e", VGA_WIDTH-1, 5);
        printchar_at(" ", VGA_WIDTH-1, 6);
        printchar_at("a", VGA_WIDTH-1, 7);
        printchar_at(" ", VGA_WIDTH-1, 8);
        printchar_at("n", VGA_WIDTH-1, 9);
        printchar_at("u", VGA_WIDTH-1, 10);
        printchar_at("m", VGA_WIDTH-1, 11);
        printchar_at("b", VGA_WIDTH-1, 12);
        printchar_at("e", VGA_WIDTH-1, 13);
        printchar_at("r", VGA_WIDTH-1, 14);*/
        normalCharListening = true;
	const char* num1 = readStr(1);
        terminal_writestring(" + ");
	const char* num2 = readStr(1);
        terminal_writestring(" = ");
        terminal_writestring(convert_to_str(charToInt(num1) + charToInt(num2)));
        }
        else if(result  == "2"){
                terminal_writestring("shutdown: OK");
                shutdown();
        }else if(result == "3"){
                terminal_writestring("reboot: OK");
                reboot();
        }
        //terminal_writestring(joinCharArr((const char*)"\n f", result));
                //terminal_writestring(convert_to_str((int)mouse_x));
        //terminal_writestring(",");
        //terminal_writestring(convert_to_str((int)mouse_y));
	//keyboardDriver();
	//inb()
	//terminal_writestring(convert_to_str(1 / 0));
	// Setup interrupts
	//idt_init();
	//create_descriptor(0, 0, 0);
        //create_descriptor(0, 0x000FFFFF, (GDT_CODE_PL0));
        //create_descriptor(0, 0x000FFFFF, (GDT_DATA_PL0));
        //create_descriptor(0, 0x000FFFFF, (GDT_CODE_PL3));
       // create_descriptor(0, 0x000FFFFF, (GDT_DATA_PL3));
}
